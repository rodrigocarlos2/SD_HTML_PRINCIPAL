<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" type="text/css">
  <link rel="stylesheet" href="theme.css" type="text/css">
  <link rel="icon" href="imagens/favicon.png">
  <title> Sistemas Distribuídos </title>
</head>

<body class="" style="background-color:#CFCFCF;">

  <div class="container">

  <div class="jumbotron" style="background-color:white;">

  <h2> Sistemas Distribuídos - 2017.1 </h2>

  <h3> Professor Dr. Francisco Airton Pereira da Silva </h3>

  <br>

  <p> Projetos </p>

  <div>
        <ul>
            <li><a href="#Section-1">SISMAC: Sistema de Monitoramento Automatizado de Colméias</a></li>
            <li><a href="#Section-2">DiagCard: Arquitetura Móvel para Diagnóstico de Arritimias Cardíacas</a></li>
            <li><a href="#Section-3">Sistema para Controle de Água dos Canteiros da UFPI </a></li>
            <li><a href="#Section-4">Análise de Desempenho de uma Sistema Distribuído para Segmentação de Imagem da Retina</a></li>
            <li><a href="#Section-5">Aplicativo para Auxiliar o Atendimento de Restaurantes</a></li>
        </ul>
   </div>

   </div>

   </div>

  <section id="Section-1">

  <div class="container">

    <div class="jumbotron" style="background-color:white;">

    <div class="jumbotron" style="background-color:white;">
      <CENTER> 
        <h3>SISMAC: Sistema de Monitoramento Automatizado de Colméias</h3>
        <h5> Ricardo Bruno </h5>
      </CENTER>
    </div>

    <h3> Resumo </h3>

    <br>

    <p align="justify">Neste trabalho foi desenvolvido um sistema distribuído para monitoramento de colmeias com abelhas tendo o objetivo de disponibilizar aos apicultores informações sobre a temperatura interna dentro da colmeia, trazendo assim mais comodidade no manejo das abelhas.</p>

    <p align="justify">O sistema foi construído utilizando a infraestrutura Internet das Coisas (IoT) como modelo. A arquitetura desse sistema consiste em sensores de temperatura, que terão função de receptores ambientais;  uma placa arduino, como o receptor dos dados colhidos pelos sensores; plataformas de IoT para recebimento e processamento dos dados e uma aplicação cliente para receber as informações referentes à temperatura da colmeia.</p>

    <h3>Componentes</h3>

    <br>

    <p align="justify">Os componentes de hardware utilizados neste projeto, foram sensores de temperatura DS18B20, uma ethernet shield w5100 e uma placa arduino mega. O sensor DS18B20 é capaz de medir temperaturas que vão de -55º C até +125º C com uma acurácia de ± 0.5º C. Este sensor vem envolto por uma cápsula de metal que o protege do ambiente externo sem interferir na sua medição essa proteção extra torna o sensor perfeito para ser utilizado em uma colmeia que é um ambiente hostil a circuitos eletrônicos.</p>

    <p align="justify"> O Mega 2560 é uma placa de microcontrolador baseada no ATmega2560. Possui 54 pinos de entrada/saída digitais (dos quais 15 podem ser utilizados como saídas PWM), 16 entradas analógicas, 4 UARTs (portas seriais de hardware), um oscilador de cristal de 16 MHz O painel Mega 2560 é compatível com a maioria dos shields projetados para o Uno e os antigos painéis Duemilanove ou Diecimila.
    </p>

    <p align="justify">O arduino Ethernet Shield w5100 permite que uma placa arduino se conecte à internet. O w5100 fornece uma pilha de rede (IP) através de TCP e UDP. Ele suporta até quatro conexões de soquete simultâneas. O shield Ethernet se conecta a uma placa arduino usando cabeçalhos longos que se estendem através do escudo. Isso mantém o layout do pino intacto e permite que outro escudo seja empilhado no topo. O Ethernet Shield possui uma conexão RJ-45 padrão, com um transformador de linha integrado e Power over Ethernet habilitado.</p>

    <h3>Plataformas de IoT</h3>

    <br>

    <p align="justify">Este projeto utilizou plataformas de IoT para armazenamento e processamento dos dados na nuvem. Para comunicação com arduino foi utilizada a plataforma thinger IO essa plataforma oferece uma infra-estrutura de IoT escalável e pronta para conectar vários de dispositivos. Uma das principais vantagens do thinger IO é a possibilidade de conexão com as principais plataformas eletrônicas: arduino, Raspberry Pi, Intel Edison.</p>

    <p align="justify">Para análise e processamento dos dados foi utilizada a plataforma Keen IO. A Keen foi projetada para oferecer aos desenvolvedores flexibilidade e extensibilidade de uma pilha de análise personalizada, sem o incômodo e risco de gerenciar a grande infraestrutura de dados. A keen oferece APIs prontas para produção, dando a possibilidade de o desenvolvedor realizar análise robustas de seus dados menos tempo.</p>

    <h3>Arquitetura</h3>

    <br>

    <p align="justify">Como a arquitetura desse projeto utiliza infraestrutura IoT, o mesmo deve conectar alguma COISA a internet, neste caso uma colmeia de abelhas onde os dados de temperatura são coletados e por um sensor de temperatura conectados a um arduino que irá formatar e enviar esses dados para a plataforma thinger IO utilizada para comunicação com o arduino e armazenamento dos dados provenientes dele. após isso os  dados são repassados para a plataforma Kenn IO que irá realizar a análise e processamento dos dados, após esse dados serem tratados podem ser disponibilizados ao apicultor e é justamente isso que acontece através da aplicação cliente que recebe os dados em forma de medidas e gráficos, a arquitetura pode ser vista na Figura abaixo.</p>
    
    <figure>
      <CENTER><img src="arq.jpg" alt="arquitetura" title="Logo do CSS" /></CENTER>
      <CENTER><figcaption>Arquitetura do SISMAC</figcaption>
      </CENTER>
    </figure>

  </div>
    
  </div> 

  </section>

  <section id="Section-2">

  <div class="container">
    <div class="jumbotron" style="background-color:white;">

    <div class="jumbotron" style="background-color:white;">
      <CENTER> 
        <h3>DiagCard: Arquitetura Móvel para Diagnóstico de Arritimias Cardíacas</h3>
        <h5> Rodrigo Leal & Ivan Filho </h5>
      </CENTER>
    </div>

    <h3> Resumo </h3>

    <br>

    <p align="justify">Neste trabalho, foi planejada e desenvolvida uma arquitetura distribuída móvel para monitoramento de frequências cardíacas tendo como objetivo de disponibilizar um método de prevenção e monitoramento de batimentos cardíacos com baixo custo.</p>

    <p align="justify">O sistema foi construído utilizando a infraestrutura Internet das Coisas (IoT) como modelo. A arquitetura desse sistema consiste em uma pulseira como sensor de batimentos cardíacos, e um smartphone como receptor e processador dos dados colhidos pelo sensor cardíaco.</p>

    <h3>Componentes</h3>

    <br>

    <p align="justify">Os componentes de hardware utilizados neste projeto foram a pulseira Mi Band 2 da Xaiomi e um smartphone para executar a aplicação. A pulseira Mi Band 2 é capaz de medir temperaturas em tempo real, além também de poder armazenar os passos e calorias gastas pelo usuário. Este sensor é adequado para monitoramento cardíaco por ser portável, o que proporciona uso em muitos lugares e atividades.</p>

    <h3>Plataformas de IoT</h3>

    <br>

    <p align="justify">
    Este projeto se em uma arquitetura de Internet das Coisas. A pulseira Mi Band 2 possui bluetooth, e com essa conexão foi feita a comunicação com o aplicativo. Para colhimento e processamento dos dados foi desenvolvida uma aplicativo Android que se baseia em uma técnica de diagnóstico cardíaco apresentada no American College of Cardiology.</p>

    <h3>Arquitetura</h3>

    <br>

    <p align="justify">A arquitetura móvel de IoT proposta é dividida entre sensor e receptor que também é capaz de processar o diagnóstico da saúde cardíaca do usuário. A Figura abaixo apresenta a arquitetura descrita.
    </p>
    
    <figure>
      <CENTER><img src="arq.png" alt="arquitetura" title="Logo do CSS" /></CENTER>
      <CENTER><figcaption>Arquitetura do DiagCard.</figcaption>
      </CENTER>
    </figure>

    <br>

  </div>
    
  </div> 

  </section>

  <section id="Section-3">

  <div class="container">
    <div class="jumbotron" style="background-color:white;">


        <div class="jumbotron" style="background-color:white;">
          <CENTER> 
            <h3> Sistema para Controle de Água dos Canteiros da UFPI </h3>
            <h5> Antônio Alves, Antônio Junior & Laise Campos </h5>
          </CENTER>
        </div>

      <h3> Resumo </h3>

      <br>

      <p align="justify"> O sistema irá tratar o desperdício de água que acontece nos canteiros da Universidade Federal do Piauí- Campus Picos, devido notarmos quando os jardineiros vão aguar os jardins ao redor dos blocos da UFPI, acontece muito desperdício de água, isso só aumenta os gastos do campus, ainda que não teria necessidade de desperdiçar tanta água já que poderiamos fazer isto de forma sustentável.</p>

      <p align="justify">Dai, surgiu a ideia do nosso projeto em fazer um sistema para tratar este problema, sistema este que é composto por programação em arduino, android, varios sensores para leitura dos contextos necessários e funcionará da seguinte forma:</p>

      <p align="justify"> No contexto inicial procuramos entender como funciona os períodos de aguar as plantas, para desenvolver a programação de acordo com as necessidades, a planta não poder ser regada em determinadas horas do dia, então será de suma importância utilizar sensores de temperatura, pelo fato de que caso a temperatura esteja alta não poderá aguar a planta porque pode ocasionar das plantas murcharem.</p>

      <p align="justify">Construímos também uma bomba d'água para que seja aguado automaticamente quando necessitar, será utilizado um rele, ele é o responsável por joga uma corrente e dar força ao motor onde a hélice gira indicando que tudo está ocorrendo corretamente e faz com que a água que se encontra no reservatório seja levada para os canteiros, terá também os sensores de temperatura que irá ler a temperatura ambiente, nos canteiros, sensores de umidades para detectar os estado do solo, contendo os seguintes contextos: Umidade alta e pouca umidade, porque contendo estas informações dos sensores poderemos saber qual canteiro está precisando ser aguado, assim quando a umidade estiver pouca os sensores indicam para poder ser acionada a bomba d'agua vinda do reservatório(caixa), pra ser aguado. </p>

      <p align="justify">Na caixa de água terá um sensor de bomba de nível mais conhecido como “boia”, que irá detectar o nível de agua da caixa. Por exemplo se a bomba de nível tiver 0 então a caixa está “seca”, então tem que reabastecer, caso a bomba de nível esteja em 1 então contém água na caixa. Na caixa terá também para ajudar detectar o nível de água um sensor ultrasonic que indica que a caixa está cheia então não precisa mais encher, o sensor ira evitar que caixa transborde evitando mais perda de água. </p>

      <br>

      <h3>FERRAMENTAS UTILIZADAS</h3>

      <br>

      <h4> Arduino Uno </h4>

        <br>

        <p align="justify">

           É uma plataforma de prototipagem eletrônica de hardware livre e de placa única, projetada com um microcontrolador Atmel AVR com suporte de entrada/saída embutido, uma linguagem de programação padrão, a qual tem origem em Wiring, e é essencialmente C/C++. O objetivo do projeto é criar ferramentas que são acessíveis, com baixo custo, flexíveis e fáceis de se usar por artistas e amadores. Principalmente para aqueles que não teriam alcance aos controladores mais sofisticados e de ferramentas mais complicadas.
            A placa pode ser alimentada pela conexão USB ou por uma fonte de alimentação externa, conforme exibido na figura abaixo: <br><br>

            <center>
                <img src="imagens/arduino-uno-POWER.png" alt="imagemArduino" width="350" height="202" />
                <figcaption><i>Figura 1. Arduino Uno</i></figcaption>
            </center><br><br>

            <p align="justify">
           A alimentação externa é feita através do conector Jack com positivo no centro, onde o valor de tensão da fonte externa deve estar entre os limites 6V. a 20V., porém se alimentada com uma tensão abaixo de 7V., a tensão de funcionamento da placa, que no Arduino Uno é 5V, pode ficar instável e quando alimentada com tensão acima de 12V, o regulador de tensão da placa pode superaquecer e danificar a placa.
            A seguir são exibidos os conectores de alimentação para conexão de shields e módulos na placa Arduino UNO:
            </p>
            <br><br>

            <center>
                <img src="imagens/5-arduino-uno-power_pins.png" alt="imagemArduino" width="350" height="202" />
                <figcaption><i>Figura 2. Conectores de alimentação da placa </i></figcaption>
            </center><br><br>
            
            • IOREF - Fornece uma tensão de referência para que shields possam selecionar o tipo de interface apropriada, dessa forma shields que funcionam com a placas Arduino que são alimentadas com 3,3V. podem se adaptar para ser utilizados em 5V, e vice-versa.<br>
     
            • RESET -  Pino conectado a pino de RESET do microcontrolador. Pode ser utilizado para um reset externo da placa Arduino.<br>
             
            • 3,3 V. - Fornece tensão de 3,3V. para alimentação de shield e módulos externos. Corrente máxima de 50 mA.<br>
             
            • 5 V - Fornece tensão de 5 V para alimentação de shields e circuitos externos.<br>
             
            • GND  - Pinos de referência, terra.<br>
             
            • VIN - Pino para alimentar a placa através de shield ou bateria externa. Quando a placa é alimentada através do conector Jack, a tensão da fonte estará nesse pino.<br>
                
        </p>
        <p align="justify">

        <br>

        <h4> Protoboard </h4>

        <br>

            <p align="justify">

            A protoboard tem a possibilidade de montar, desenvolver e testar diversos circuitos eletrônicos, tudo sem ter que soldar os componentes. Sendo assim, a protoboard é o lugar mais recomendado para montar este circuito e efetuar todos os testes necessários. Uma outra utilização muito comum é interligar sensores e circuitos integrados (CIs) aos diversos microcontroladores disponíveis como, por exemplo, o Arduino. Na imagem abaixo mostra as três áreas disponíveis nas protoboards, a área para montagem de CIs (parte central da protoboard), a área para distribuição da alimentação elétrica (duas linhas superiores e inferiores) e a área para montagem dos componentes (colunas). As linhas azuis representam as ligações internas da protoboard, ou seja, internamente elas já estão interligadas.

            </p>

            <br><br>

            <center>
                <img src="imagens/17_img_1_H.png" alt="imagemProtoboard" width="350" height="202" />
                <figcaption><i>Figura 3. Protoboard</i></figcaption>
            </center><br>

        
        </p>
        <p align="justify">

        <br>

        <h4> Sensor DS18B20 </h4>

        <br>

           É um sensor digital de temperatura com características interessantes para uso com o Arduino, que são o baixo custo e a facilidade de uso. O sensor pode efetuar leituras com precisão de até ±0,5 ºC, e enviar as informações para o microcontrolador utilizando apenas 1 fio.<br><br>


            <center>
                <img src="imagens/142_1_H.png" alt="imagemsensor" width="350" height="202" />
                <figcaption><i>Figura 4. Sensor DS18B20</i></figcaption>

            </center><br>

        

        </p>
       <p align="justify">

       <br>

       <h4> Sensor de umidade do solo Higrômetro </h4>

        <br>

        <p align="justify">

       O sensor de umidade do solo consiste em 2 partes: uma sonda que entra em contato com o solo, e um pequeno módulo contendo um chip comparador LM393 (datasheet), que vai ler os dados que vêm do sensor e enviá-los para o microcontrolador, no caso, um Arduino Uno. Como saída, temos um pino D0, que fica em nível 0 ou 1 dependendo da umidade, e um pino de saída analógica (A0), que possibilita monitorar com maior precisão usando uma porta analógica do microcontrolador. O módulo tem um led que indica quando a placa está sendo alimentada corretamente, e outro que acende quando a saída digital for acionada. A sensibilidade do módulo é ajustada por meio do potenciômetro existente na placa.

       </p>

       <br><br>

        <center>
            <img src="imagens/Sensor-de-solo-umidade-modulo.png" alt="imagemsensor" width="350" height="202" />
            <figcaption><i>Figura 5. Sensor de umidade do solo Higrômetro</i></figcaption>
        </center><br>

            
        
      </p>
      <p align="justify">

      <br>

      <h4> Módulo Rele </h4>

        <br>
        <p align="justify">
       O relé 5V pode ser também usado com AVR, PIC, Raspberry, 8051, ARM ou até mesmo o seu circuito eletrônico personalizado. Usando dois pinos do módulo relé arduino, pode controlar cargas como lâmpadas, motores, fechaduras e eletrodomésticos, desde que a corrente de operação não ultrapasse 10 A (ampéres). Cada relé desse módulo suporta cargas de até 10 A, em 125 VAC, 250 VAC ou 30 VDC. Leds indicadores mostram o estado do relé  (ligado/desligado) em cada canal. O módulo já contém todo o circuito de proteção para evitar danos ao microcontrolador, e possui baixa corrente de operação. 

       </p>

       <br><br>

        <center>
            <img src="imagens/moduloRele.jpg" alt="imagemsensor" width="350" height="202" />
            <figcaption><i>Figura 6. Módulo Rele</i></figcaption>
        </center><br>

        <br>
        
      </p>
      <p align="justify">

        <h4> Bomba d'água </h4>

        <br>

        Material utilizado para construção da bomba:<br><br>
        •   Duas tampas de garrafa pet;<br>
        •   Meio metro de mangueira de nível;<br>
        •   Um motor de 5V;<br>
        •   Plástico (utilizado para fabricar a hélice);<br>
        •   Cola quente e supercola;<br><br>

       FABRICAÇÃO:<br><br>

       <p align="justify">

       Inicialmente foi feito dois buracos em uma das tampas (na parte superior e na lateral), um para encaixar um pedaço da mangueira de nível (que foi dividida em dois pedaços), que será encaixado no furo da lateral, e o outro para encaixar o motor, que vai encaixar na parte superior da tampa, e na outra tampa foi feito somente um furo para encaixar outro pedaço da mangueira de nível. Após ser feito os furos na primeira tampa, o motor foi encaixado no furo e foi colado com supercola, e na superfície entre a tampa e motor utilizou-se bastante cola quente para não ocorre vazamento de água.

       </p>


       <br>

       <p align="justify">

       Um pedaço do plástico foi cortado em forma circular e feito um furo no centro para encaixar o motor, cortou-se mais quatro pedaços pequenos de plástico em forma de retângulo e colado no outro pedaço circular para formar a hélice, após montar a hélice, foi encaixada a mesma no motor por dentro da tampa de garrafa pet, usou-se cola quente para que a mesma não desencaixe do motor (é importante observar a rotação da hélice e verificar se a mesma está girando sem nenhum empecilho).

       </p>

       <br>

       <p align="justify">

       Depois de ter feito isso tudo pegou-se a outra tampa de garrafa pet, e cola encaixando na outra tampa, para não ocorrer vazamento utiliza-se bastante cola quente. Depois de encaixar uma tampa na outra, pega outro pedaço da mangueira de nível e cola encaixando no buraco da outra tampa, novamente utilize bastante cola quente para não ocorrer vazamento. Fizemos o teste com água para ver se a bomba funcionou, para ligar o motor utilizeilizamos inicialmente uma bateria de celular, após o teste com a bateria, liagamos a bomba no rele, para o funcionamnto do sistema de irrigação.

       </p>

       <br>

            <center>
                <img src="imagens/bomba.jpg" alt="imagemsensor" width="350" height="202" />
                <figcaption><i>Figura 7. Bomba d'água</i></figcaption>
            </center><br>


        
      </p>
    
      <p align="justify">

      <br>

      <h4> Sensor Ultrasônico </h4>

        <br>

        <p align="justify">

       É um componente muito comum em projetos com Arduino, que permite fazer leituras de distâncias entre 2 cm e 4 metros, com precisão de 3 mm. Pode ser utilizado simplesmente para medir a distância entre o sensor e um objeto, como para acionar portas do microcontrolador, desviar um robô de obstáculos, acionar alarmes, etc.

       </p>

       <br>

        <center>
            <img src="imagens/sen.jpg" alt="imagemsensor" width="350" height="202" />
            <figcaption><i>Figura 8. Sensor Ultrasonic</i></figcaption>
        </center><br>
        
      </p>

      <p align="justify">

      <br>

      <h4> Sensor de Nível de Líquidos ao Arduino </h4>

        <br>

        <p align="justify">

       É um sensor feito de material plástico (PP, segundo o fabricante), composto de uma haste na qual desliza um cilindro feito de material flutuante. Esse cilindro possui um ímã que aciona um sensor magnético no meio da haste, que por sua vez fecha o contato dos 2 fios que saem do sensor, ou seja é uma boia com fios.<br><br>

       </p>

        <center>
            <img src="imagens/Sensor_liquido_vertical_1.JPG" alt="imagemsensor" width="350" height="202" />
            <figcaption><i>Figura 9. Sensor de Nível de Líquidos</i></figcaption>
        </center><br><br>
        
      </p>

      <br>

      <center><p><b>FUNCIONAMENTO DO PROJETO</b></p></center>

      <p align="justify">

     O vídeo abaixo mostra o projeto funcionando, porém na fase inicial. Terá também uma maquete representando os canteiros da federal onde o projeto arduíno será montado sobre ela para similar mais realidade na apresentação final.<br><br> 

     </p>

      <center>
          <video width="1000" height="500" controls="controls" >
                <source src="videos/videoProjeto.mp4" type="video/mp4">
                <object data="15/06/2017" width="1000" height="500">
                    <embed width="1000" height="500" src="videos/videoProjeto.mp4">
                </object>
          </video>
            
      </center>


     
     </div>

     
     
  </div>

  </section>

  <section id="Section-4">

   <div class="container">
    <div class="jumbotron" style="background-color:white;">

        <div class="jumbotron" style="background-color:white;">
          <CENTER> 
            <h3> Análise de Desempenho de uma Sistema Distribuído para Segmentação de Imagem da Retina </h3>
            <h5> Marcus Vinícios & Edson Damasceno </h5>
          </CENTER>
        </div>

        <h3> Resumo </h3>

        <br>

        <p align="justify">
            Neste trabalho, apresentamos o desenvolvimento de um sistema mobile para segmentação de imagens
            da retina em computação em nuvem. O sistema funciona primeiramente com a seleção de uma imagem
            no dispositivo móvel, para posteriormente ser enviada ao servidor para realizar a segmentação da imagem.

            Optou-se por utilizar esse arquitetura devido a limitação dos dispositivos móveis, como bateria,
            processamento, e memória. Assim ao utilizar um servidor ele terá a funcionalidade de relizar as
            operações de processamento digital de imagens e retornar os resultados, diminuindo assim as operações
            no dispositivo móvel otimizando a aplicação sem comprometer os resultados.
        </p>

        <p align="justify">
            Para o desenvolvimento da aplicação que se basea na arquitetura cliente-servidor, ou seja,
            o cliente requisita e detém dados, e o servidor processa e faz a manutenção da informação.

            Assim utilizamos as seguintes tecnologias:

        </p>

        <ul>

            <ul> Linguagem java e SDK android </ul>

            <ul> Middleware rabbitmq </ul>

            <ul> Linguagem de programação python </ul>

            <ul> Biblioteca OpenCV para manipulação de imagens </ul>

        </ul>

        <p align="justify">
            A linguagem de programação java foi para programar em android para desenvolver a aplicação
            mobile contanto com a IDE() Android Studio. O rabbitmq é um middle de troca de mensagens para
            manter o controle, segurança, e entregas corretas das menssagens entre cliente e servidor.
            Foi utilizado um middleware por estar envolvido diferentes plataformas e linguagens de programação
            envolvidos, sendo necessário para a interação entre elas. A linguagem de programação python com a
            biblioteca OpenCV é utilizada pora o processamento digital de imagens e geração de gráficos sobre
            o desempenho da aplicação.

        </p>

        <h4> Funcionamento </h4>

        <br>

        <p align="justify">

            No lado cliente com o celular android, o usuário pode selecionar a imagem em seu celular, e ao selecionar
            um botão fica apto a enviar ao middleware no sevidor . No servidor a imagem é realizado por um pré-processamento
            para a eliminação de ruídos, para posteriormente ser segmentada e retornada ao cliente. A imagem abaixo demostra
            a interface no lado cliente.

        </p>

        <br>

        <figure>
            <CENTER><img src="imagens/phone.jpg" alt="Seleção de Imagem no Cliente" title="Seleção da imagens no celular" width="220" height="380" />
        </figure>

        <br>

        <p> Abaixo tem-se o resultado de uma segmentação com o algoritmo de segmentação Otsu</p>

        <br>

        <figure>
            <CENTER><img src="imagens/otsu_400_cinza_0.png" alt="Segmentação com Otsu" title="Seleção da imagens no celular" width="300" height="300" />
        </figure>

        <br>

        <p> Abaixo tem-se o resultado de uma segmentação com o algoritmo de segmentação K-means</p>

        <br>

        <figure>
            <CENTER><img src="imagens/kmeans_400_cinza_0.png" alt="Segmentação com K-means" title="Seleção da imagens no celular" width="310" height="300" />
        </figure>

        <br>

        </div>
    
  </div>

  </section>

  <section id="Section-5">

  <div class="container">
    <div class="jumbotron" style="background-color:white;">

      <div class="jumbotron" style="background-color:white;">
          <CENTER> 
            <h3> Aplicativo para Auxiliar o Atendimento de Restaurantes </h3>
            <h5> Boaz Sousa & Maria de Fátima </h5>
          </CENTER>
        </div>

      <div class="jumbotron" style="background-color:white;">   
      <p align="justify"> O bom atendimento ao cliente deve ser prioridade de qualquer negócio,
          especificamente em um restaurante, deve existir uma agilidade no momento de transferir
          o pedido do cliente à cozinha, no modo tradicional isso custa tempo, a demora está
          relacionada especificamente ao deslocamento do atendente até a cozinha onde o Chefe
          precisaria saber o pedido para então servir. Com essa necessidade, apresentamos um
          Sistema Distribuído para um Restaurante que possa agilizar o atendimento ao cliente.</p>
          
         <p align="justify">Na maioria dos estabelecimentos das cidades enfrenta-se uma dificuldade que é
          os serviços destinados no atendimento aos clientes. É fato que muitos restaurantes
          possuem uma certa desorganização e demora no atendimento, que terminam insatisfeitos
          pela falta de um atendimento rápido e de qualidade. Esse problema dá-se também por
          conta da grande quantidade de clientes nos estabelecimentos, torna-se uma tarefa bastante
          demorada o fato de os garçons precisarem escrever cada pedido, realizar a entrega ao
          chefe de cozinha e retornar para o atendimento aos demais clientes.</p> 
          
          <p align="justify">O Sistema Distribuído para Restaurante, funcionaria assim, os atendentes teriam
          aplicativos Android, os quais seriam responsáveis por recolher os pedidos dos clientes,
          esses dados iriam diretamente para um servidor, que estaria localizado na cozinha, sendo
          visualizados pelo Chefe, e imediatamente os pratos seriam feitos, isso diminuiria o tempo
          de entrega do pedido ao cliente, pois, o mesmo seria recolhido e enviado diretamente a
          cozinha, no caso onde ficaria o servidor.</p>
          
          <p align="justify">Inicialmente os atendentes (garçons) recolhem algumas informações para o
          aplicação Android, como o número da mesa, a quantidade de pessoas em uma mesa, o
          mesmo tem acesso ao cardápio digital, que selecionará os pedidos feitos pelo cliente e em
          seguida conclui o pedido, enviando-o ao servidor. O aplicativo Android terá uma 
          funcionalidade na qual o atendente avisará que a mesa está liberada, após a efetuação do
          pagamento. Utilizaremos a arquitetura Cliente/Servidor, pois é uma arquitetura na qual o
          processamento da informação é dividido em módulos ou processos distintos. Um
          processo é responsável pela manutenção da informação (servidores) e outros responsáveis
          pela obtenção dos dados (os clientes). Além disso, utilizaremos o Message Broker.</p>

          <br>

          <figure>
            <center>
            <img src = "Restaurante.png" alt = "Restaurante" width ="600px" height="600px" />
          </center>

          </figure>
          <br>
          <br>
          <br>
          <h5>Como usar:</h5> 

          <br>

          <figure>
              <center>
                <img src = "1.png" alt = "Restaurante" width ="300px" height="400px" /> 
                <figcaption>Tela de Login, pode logar o atendente para o menu principal e cadastrar um novo atendente</figcaption>
                <br> 
                <br> 
                <img src = "2.png" alt = "Restaurante" width ="300px" height="400px" /> <figcaption> Tela Menu Principal, onde poderão ser feitos pedidos e também será possivel liberar a mesa</figcaption>
                <br> 
                <br>  
                <img src = "3.png" alt = "Restaurante" width ="300px" height="400px" /> <figcaption>Tela Pratos Adicionais, serão escolhidos os pratos e informados ao aplicativo</figcaption>
                <br> 
                <br> 
                <img src = "4.png" alt = "Restaurante" width ="300px" height="400px" /> <figcaption>Tela Bebidas, serão escolhidas as bebidas e informadas ao aplicativo</figcaption>
                <br> 
                <br>  
                <img src = "5.png" alt = "Restaurante" width ="300px" height="400px" /> <figcaption>Tela Sobremesas, serão escolhidas as sobremesas e informadas ao aplicativo</figcaption>
                <br> 
                <br>  
                <img src = "6.png" alt = "Restaurante" width ="300px" height="400px" /> <figcaption>Tela de Liberar a Mesa, é possivel liberar mesas</figcaption>
                <br> 
                <br>  
                <img src = "7.png" alt = "Restaurante" width ="300px" height="400px" /> <figcaption>Tela de Cadastro, será cadastrado um novo atendente</figcaption>  
              </center>
           </figure>

        </div> 
        
  </div>

  </section>

  <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js"></script>
  <script src="https://pingendo.com/assets/bootstrap/bootstrap-4.0.0-alpha.6.min.js"></script>
</body>

</html>